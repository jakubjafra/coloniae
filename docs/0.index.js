(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ "./app/externals/extend.js":
/*!*********************************!*\
  !*** ./app/externals/extend.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tExtendJS 0.2.2\n\tMore info at http://extendjs.org\n\n\tCopyright (c) 2013+ ChrisBenjaminsen.com\n\n\tPermission is hereby granted, free of charge, to any person obtaining a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in\n\tall copies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n\tTHE SOFTWARE.\n*/\n(function(global){\n    \"use strict\";\n\t//Helper method for creating an super copied object clone\n\tfunction initialize(method){\n\t\t//Recursivly execute parent methods.\n\t\tif(method.parent instanceof Function){\n\t\t\tinitialize.apply(this,[method.parent]);\n\t\t\tthis.super = cloneCopy(this,\n\t\t\t\tsuperCopy(this,this.constructor)\n\t\t\t);\n\t\t}\n\t\tmethod.apply(this, arguments);\n\t}\n\n\t//Helper method which allows for super referances.\n\tfunction cloneCopy(from, to){\n\t\tfor(var x in from){\n\t\t\tif(x !== \"super\" && from[x] instanceof Function){\n\t\t\t\t//Never create circular super referances.\n\t\t\t\tto[x] = from[x].super || superCopy(from, from[x]);\n\t\t\t}\n\t\t}\n\t\treturn to;\n\t}\n\n\tfunction superCopy(scope, method){\n\t\tvar scopeSuper = scope.super;\n\t\treturn method.super = function(){\n\t\t\tscope.super = scopeSuper;\n\t\t\treturn method.apply(scope, arguments);\n\t\t}\n\t}\n\n\t//Create Class object\n\tglobal.Class = function(){};\n\tglobal.Class.extend = function ext(to){\n\t\tfunction child(){\n\t\t\t//Prevent the prototype scope set executing the constructor.\n\t\t\tif(initialize !== arguments[0]){\n\t\t\t\t//Create inhereted object\n\t\t\t\tinitialize.apply(this,[to]);\n\t\t\t\t//Setup scope for class instance method calls\n\t\t\t\tcloneCopy(this,this);\n\t\t\t\tif(this.initializer instanceof Function)\n\t\t\t\t\tthis.initializer.apply(this);\n\t\t\t\tthis.constructor.apply(this,arguments);\n\t\t\t}\n\t\t}\n\n\t\t//Set prototype and constructor enabeling propper type checking.\n\t\tchild.prototype = new this(initialize);\n\t\tchild.prototype.constructor = child;\n\n\t\t//Return expected result from toString\n\t\tchild.toString = function(){\n\t\t\treturn to.toString()\n\t\t}\n\n\t\t//Allow the child to be extended.\n\t\tchild.extend = function(target){\n\t\t\t//Create parent referance and inherentence path.\n\t\t\ttarget.parent = to;\n\t\t\treturn ext.apply(child,arguments);\n\t\t}\n\t\n\t\treturn child\n\t}\n\t//Bootstrap Class by inheriting itself with empty constructor.\n\tglobal.Class = global.Class.extend(function() {\n        this.constructor=function(){}\n    });\n})(this)\n\n\n//# sourceURL=webpack:///./app/externals/extend.js?");

/***/ }),

/***/ "./app/scripts/graphics.js":
/*!*********************************!*\
  !*** ./app/scripts/graphics.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\ngraphics.js\n\n*/\n\nKEY_ARROW_UP = 38;\nKEY_ARROW_DOWN = 40;\nKEY_ARROW_LEFT = 37;\nKEY_ARROW_RIGHT = 39;\n\nKEYBOARD_MOVE_MAP_DIFF = 20;\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\"),\t\t\n\t\t__webpack_require__(/*! ./logic */ \"./app/scripts/logic.js\"),\n\t\t__webpack_require__(/*! ./graphics/framework */ \"./app/scripts/graphics/framework.js\"),\n\t\t__webpack_require__(/*! ./graphics/gameplayState */ \"./app/scripts/graphics/gameplayState.js\"),\n\t\t__webpack_require__(/*! ./graphics/drawMethod */ \"./app/scripts/graphics/drawMethod.js\"),\n\t\t__webpack_require__(/*! ./graphics/tilePicker */ \"./app/scripts/graphics/tilePicker.js\"),\n\t\t__webpack_require__(/*! ./graphics/layerManager */ \"./app/scripts/graphics/layerManager.js\"),\n\t\t__webpack_require__(/*! ./graphics/analytics */ \"./app/scripts/graphics/analytics.js\")\n\t\t], __WEBPACK_AMD_DEFINE_RESULT__ = (function(\n\t\t_,\n\t\tLogic,\n\t\tframework,\n\t\tgameplayState,\n\t\tdraw,\n\t\tpicker,\n\t\tlayerManager,\n\t\tanalyticModule\n\t){\n\n\tvar wasAnyAction = false;\n\n\tfunction makeClick(clickedTile, hoverTile, mouseX, mouseY){\n\t\tif(gameplayState.choosedSth instanceof Ship){\n\t\t\tif(clickedTile.terrainLevel < SHALLOW){\n\t\t\t\tconsole.log(\"moving ship /#\" + gameplayState.choosedSth.id + \"/ to (\" + clickedTile.x + \", \" + clickedTile.y + \")\");\n\n\t\t\t\tgameplayState.choosedSth.moveTo(tiles.coords(clickedTile));\n\t\t\t}\n\n\t\t\t// jak kliknięto w wyspę to usuwamy zaznaczenie na jednostce\n\t\t\tif(clickedTile.islandId != INVALID_ID)\n\t\t\t\tgameplayState.choosedSth = undefined;\n\t\t}\n\n\t\t// zaznaczenie jednostki\n\t\tif(clickedTile.unitId != INVALID_ID)\n\t\t\tgameplayState.choosedSth = militaryUnits[clickedTile.unitId];\n\t\t// kliknięcie w budynek\n\t\telse if(clickedTile.buildingData != undefined)\n\t\t\tgameplayState.choosedSth = clickedTile.buildingData;\n\t\t// albo ostatecznie w nic nie kliknięto.\n\t\telse if(!(gameplayState.choosedSth instanceof Ship)) // <- TODO: to jest chujowe, tymczasowe rozwiązanie\n\t\t\tgameplayState.choosedSth = undefined;\n\n\t\t// TODO: Usunąć to gówno.\n\t\t// Przemyśleć jak, przydałby się na pewno jakiś \"global controller\" do tego typu\n\t\t// zmiennych jak gameplayState.choosedSth (może zmiana paradygmatu GUI?)\n\t\tif(!wasAnyAction)\n\t\t\tgameplayState.guiClickHandler(mouseX, mouseY);\n\t}\n\n\t// dodaje budynki na podstawie prostokąta do gameplayState.buildingsToPlacement\n\tfunction fillBuildingsToPlacement(){\n\t\tgameplayState.buildingsToPlacement = [];\n\n\t\tvar fakeBegin = gameplayState.placementRectangle.begin;\n\t\tvar fakeEnd = gameplayState.placementRectangle.end;\n\n\t\tif(fakeBegin == undefined || fakeEnd == undefined)\n\t\t\treturn;\n\n\t\tvar begin = _.clone(fakeBegin);\n\t\tvar end = _.clone(fakeEnd);\n\n\t\tif(begin.x > end.x){\n\t\t\tbegin.x = fakeEnd.x;\n\t\t\tend.x = fakeBegin.x;\n\t\t}\n\n\t\tif(begin.y > end.y){\n\t\t\tbegin.y = fakeEnd.y;\n\t\t\tend.y = fakeBegin.y;\n\t\t}\n\n\t\tif(!tiles.exsist(begin) || !tiles.exsist(end))\n\t\t\treturn;\n\n\t\tfor(var i = begin.x; i <= end.x; i += gameplayState.testBuilding.width)\n\t\t\tfor(var j = begin.y; j <= end.y; j += gameplayState.testBuilding.height)\n\t\t\t\tif(canBeBuild(i, j, gameplayState.testBuilding))\n\t\t\t\t\tgameplayState.buildingsToPlacement.push(tiles.coords(i, j));\n\t}\n\n\t// dodaje istniejące budynki na podstawie prostokąta do gameplayState.buildingsToPlacement\n\tfunction fillBuildingsToRemove(){\n\t\tgameplayState.buildingsToPlacement = [];\n\n\t\tvar fakeBegin = gameplayState.placementRectangle.begin;\n\t\tvar fakeEnd = gameplayState.placementRectangle.end;\n\n\t\tif(fakeBegin == undefined || fakeEnd == undefined)\n\t\t\treturn;\n\n\t\tvar begin = _.clone(fakeBegin);\n\t\tvar end = _.clone(fakeEnd);\n\n\t\tif(begin.x > end.x){\n\t\t\tbegin.x = fakeEnd.x;\n\t\t\tend.x = fakeBegin.x;\n\t\t}\n\n\t\tif(begin.y > end.y){\n\t\t\tbegin.y = fakeEnd.y;\n\t\t\tend.y = fakeBegin.y;\n\t\t}\n\n\t\tif(!tiles.exsist(begin) || !tiles.exsist(end))\n\t\t\treturn;\n\n\t\t// usuń wszystkie budynki do selektora\n\t\tfor(var i = begin.x; i <= end.x; i++)\n\t\t\tfor(var j = begin.y; j <= end.y; j++)\n\t\t\t\tif(tiles.exsist(i, j) && tiles.at(i, j).buildingData != null)\n\t\t\t\t\tgameplayState.buildingsToPlacement.push(tiles.coords(i, j));\n\t}\n\n\tfunction endWidePlacement(){\n\t\tgameplayState.placementRectangle.begin = tiles.coords(-1, -1);\n\t\tgameplayState.placementRectangle.end = tiles.coords(-1, -1);\n\n\t\tgameplayState.buildingsToPlacement = [];\n\n\t\tgameplayState.useWidePlacement = false;\n\t}\n\n\treturn new framework(new function(){\n\t\tthis.resources = [ \"atlas\" ];\n\n\t\tthis.fullscreen = true;\n\n\t\tthis.onKeyDown = function(key){};\n\t\tthis.onKeyUp = function(key){\n\t\t\tswitch(key){\n\t\t\t\tcase KEY_ARROW_UP:\n\t\t\t\t\t\tgameplayState.cameraPosition.y += KEYBOARD_MOVE_MAP_DIFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase KEY_ARROW_DOWN:\n\t\t\t\t\t\tgameplayState.cameraPosition.y -= KEYBOARD_MOVE_MAP_DIFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase KEY_ARROW_LEFT:\n\t\t\t\t\t\tgameplayState.cameraPosition.x += KEYBOARD_MOVE_MAP_DIFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase KEY_ARROW_RIGHT:\n\t\t\t\t\t\tgameplayState.cameraPosition.x -= KEYBOARD_MOVE_MAP_DIFF;\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tendWidePlacement();\n\n\t\t\t\t\tgameplayState.buildMode = false;\n\t\t\t\t\tgameplayState.removeMode = false;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t};\n\n\t\tthis.onMouseEnter = function(){};\n\n\t\tthis.onMouseLeave = function(){\n\t\t\tgameplayState.hoveredTile = undefined;\n\n\t\t\tif(!gameplayState.buildMode || !gameplayState.removeMode)\n\t\t\t\tgameplayState.moveMap = false;\n\t\t\telse {\n\t\t\t\tgameplayState.buildingsToPlacement = [];\n\n\t\t\t\tgameplayState.placementRectangle.begin = tiles.coords(-1, -1);\n\t\t\t\tgameplayState.placementRectangle.end = tiles.coords(-1, -1);\n\t\t\t\t\n\t\t\t\tgameplayState.useWidePlacement = false;\n\t\t\t}\n\t\t};\n\n\t\tvar oldX = undefined;\n\t\tvar oldY = undefined;\n\n\t\tvar timeout = null;\n\n\t\tthis.onMouseMove = function(x, y){\n\t\t\t// pobieranie hover nad danym tilesem\n\t\t\tgameplayState.hoveredTile = picker.byGeometry(x, y);\n\n\t\t\t// jeśli myszka się nie rusza to można użyć colorPickingu dla większej dokładności\n\t\t\tclearTimeout(timeout);\n\t\t\ttimeout = setTimeout(function(){\n\t\t\t\tgameplayState.hoveredTile = picker.byColor(x, y);\n\t\t\t}, 100);\n\n\t\t\t// poruszanie kamerą\n\t\t\toldX = oldX || x;\n\t\t\toldY = oldY || y;\n\n\t\t\tif(gameplayState.moveMap && !(gameplayState.buildMode || gameplayState.removeMode)){\n\t\t\t\tgameplayState.cameraPosition.x += (x - oldX);\n\t\t\t\tgameplayState.cameraPosition.y += (y - oldY);\n\t\t\t}\n\n\t\t\toldX = x;\n\t\t\toldY = y;\n\n\t\t\t// ~~~\n\n\t\t\t// to jest tutaj tylko po to by można było wyświetlić podświetlenie\n\t\t\t// informację dla gracza jakie budynki się gdzie wybudują\n\t\t\tif((gameplayState.buildMode && gameplayState.testBuilding != undefined) || gameplayState.removeMode){\n\t\t\t\tgameplayState.placementRectangle.end = picker.byGeometry(x, y);\n\n\t\t\t\tif(!gameplayState.useWidePlacement)\n\t\t\t\t\tgameplayState.placementRectangle.begin = gameplayState.placementRectangle.end;\n\n\t\t\t\tif(gameplayState.buildMode)\n\t\t\t\t\tfillBuildingsToPlacement();\n\t\t\t\telse\n\t\t\t\t\tfillBuildingsToRemove();\n\t\t\t}\n\t\t};\n\n\t\tthis.onMouseDown = function(x, y){\n\t\t\tgameplayState.moveMap = true;\n\n\t\t\tif(gameplayState.buildMode || gameplayState.removeMode){\n\t\t\t\tgameplayState.placementRectangle.begin = picker.byGeometry(x, y);\n\t\t\t\tgameplayState.useWidePlacement = true;\n\t\t\t}\n\t\t};\n\n\t\tthis.onMouseUp = function(x, y){\n\t\t\tgameplayState.moveMap = false;\n\n\t\t\t// kolejność zawsze jest taka: zdarzenie -> onMouseUp -> onMouseClick\n\t\t\t// ustawienie tutaj tej zmiennej (i ew. poinformowanie że wybudowano coś)\n\t\t\t// usuwa buga powowdującego automatyczne klikniecie w nowo wybudowany budynek\n\t\t\twasAnyAction = false;\n\n\t\t\tif(gameplayState.buildMode || gameplayState.removeMode){\n\t\t\t\t// uaktualnij placementRectangle\n\t\t\t\tgameplayState.placementRectangle.end = picker.byGeometry(x, y);\n\n\t\t\t\tif(gameplayState.buildMode){\n\t\t\t\t\tfillBuildingsToPlacement();\n\n\t\t\t\t\t// wybuduj budynki z gameplayState.buildingsToPlacement\n\t\t\t\t\tfor(var i = 0; i < gameplayState.buildingsToPlacement.length; i++){\n\t\t\t\t\t\tvar buildingCoords = gameplayState.buildingsToPlacement[i];\n\n\t\t\t\t\t\tvar structure = structsClass[gameplayState.testBuilding.index];\n\t\t\t\t\t\tnew structure.class(buildingCoords.x,\n\t\t\t\t\t\t\t\t\t\t\tbuildingCoords.y,\n\t\t\t\t\t\t\t\t\t\t\tcountries[0],\n\t\t\t\t\t\t\t\t\t\t\tundefined,\n\t\t\t\t\t\t\t\t\t\t\tgameplayState.testBuilding.rotation);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfillBuildingsToRemove();\n\n\t\t\t\t\tfor(var i = 0; i < gameplayState.buildingsToPlacement.length; i++){\n\t\t\t\t\t\tvar building = tiles.at(gameplayState.buildingsToPlacement[i]).buildingData;\n\n\t\t\t\t\t\tif(building != null)\n\t\t\t\t\t\t\tbuilding.remove();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// usuń zaznaczenie:\n\n\t\t\t\tgameplayState.buildingsToPlacement = [];\n\n\t\t\t\tgameplayState.placementRectangle.begin = tiles.coords(-1, -1);\n\t\t\t\tgameplayState.placementRectangle.end = tiles.coords(-1, -1);\n\t\t\t\t\n\t\t\t\tgameplayState.useWidePlacement = false;\n\n\t\t\t\twasAnyAction = true;\n\t\t\t}\n\t\t};\n\n\t\tthis.onMouseClick = function(x, y){\n\t\t\tclickedTile = picker.byColor(x, y);\n\n\t\t\tif(clickedTile != undefined){\n\t\t\t\tconsole.log(\"clicked tile (\" + clickedTile.x + \", \" + clickedTile.y + \")\", false);\n\t\t\t\t\n\t\t\t\tmakeClick(clickedTile, gameplayState.hoveredTile, x, y);\n\t\t\t} else\n\t\t\t\tconsole.log(\"out of board click\");\n\t\t};\n\n\t\tthis.onRender = function(delta, ctx, resources){\n\t\t\tdraw(delta, ctx, gameplayState.cameraPosition, function(layerName){ return layerManager.getLayer(layerName); }, false);\n\t\t};\n\t\t\n\t\tthis.onUpdate = function(delta){\n\t\t\tLogic.update(delta);\n\t\t\tanalyticModule.update(delta);\n\t\t};\n\n\t\tthis.onLoadResources = function(resources){\n\t\t\tlayerManager.setBaseLayer(resources['atlas']);\n\n\t\t\tlayerManager.createLayer(\"lighter_1\", function(context, baseLayer){\n\t\t\t\tcontext.globalCompositeOperation = \"lighter\";\n\t\t\t\tcontext.globalAlpha = 0.1;\n\t\t\t\tcontext.drawImage(baseLayer, 0, 0);\n\t\t\t});\n\n\t\t\tlayerManager.createLayer(\"lighter_3\", function(context, baseLayer){\n\t\t\t\tcontext.globalCompositeOperation = \"lighter\";\n\t\t\t\tcontext.globalAlpha = 0.33;\n\t\t\t\tcontext.drawImage(baseLayer, 0, 0);\n\t\t\t});\n\n\t\t\tlayerManager.createLayer(\"darkner\", function(context, baseLayer){\n\t\t\t\tcontext.globalCompositeOperation = \"multiply\";\n\t\t\t\tcontext.drawImage(baseLayer, 0, 0);\n\t\t\t});\n\n\t\t\tlayerManager.createLayer(\"oranger_tmp\", function(context, baseLayer){\n\t\t\t\tcontext.globalCompositeOperation = 'source-in';\n\t\t\t\tcontext.fillStyle = \"#CB9A50\"; // http://paletton.com/#uid=7050I0kmRmRfLtbjtpupujttbfL\n\t\t\t\tcontext.globalAlpha = 0.33;\n\t\t\t\tcontext.fillRect(0, 0, context.canvas.width, context.canvas.height);\n\t\t\t});\n\n\t\t\tlayerManager.createLayer(\"oranger\", function(context, baseLayer){\n\t\t\t\tcontext.drawImage(layerManager.getLayer(\"oranger_tmp\"), 0, 0);\n\t\t\t});\n\n\t\t\tlayerManager.createLayer(\"red_tmp\", function(context, baseLayer){\n\t\t\t\tcontext.globalCompositeOperation = 'source-in';\n\t\t\t\tcontext.fillStyle = \"#9B2E20\"; // http://paletton.com/#uid=7050I0kmRmRfLtbjtpupujttbfL\n\t\t\t\tcontext.globalAlpha = 0.5;\n\t\t\t\tcontext.fillRect(0, 0, context.canvas.width, context.canvas.height);\n\t\t\t});\n\n\t\t\tlayerManager.createLayer(\"red\", function(context, baseLayer){\n\t\t\t\tcontext.drawImage(layerManager.getLayer(\"red_tmp\"), 0, 0);\n\t\t\t});\n\n\t\t\t// ~~~\n\n\t\t\tpicker.initColorpicking(resources);\n\t\t};\n\t});\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/graphics.js?");

/***/ }),

/***/ "./app/scripts/graphics/analytics.js":
/*!*******************************************!*\
  !*** ./app/scripts/graphics/analytics.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\nalalytic.js\n\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../logic */ \"./app/scripts/logic.js\")\n\t\t], __WEBPACK_AMD_DEFINE_RESULT__ = (function(\n\t){\n\n\tTYPE_OK = -1;\n\tTYPE_NEED = 0;\n\tTYPE_DEMAND = 1;\n\n\tfunction State(productId, msg, type){\n\t\tthis.productId = productId;\n\t\tthis.type = type;\n\n\t\tthis.timeSinceLastCall = 0;\n\t}\n\n\t// indeksowanie: [StatesCount * island.id + State.type]\n\tvar states = {};\n\n\tfunction getState(islandId, productId){\n\t\treturn states[goods.length * islandId + productId];\n\t}\n\n\tfunction setState(islandId, productId, type){\n\t\tvar state;\n\t\tif((state = getState(islandId, productId)) == undefined)\n\t\t\tstates[goods.length * islandId + productId] = new State(productId, type);\n\t\telse\n\t\t\tstate.type = type;\n\t}\n\n\tfunction isSomethingMissingInPlayerHouses(){\n\t\tfor(var islandId in islands){\n\t\t\tvar island = islands[islandId];\n\t\t\tif(island.houseGroups[0] == undefined)\n\t\t\t\tcontinue;\n\n\t\t\t// Sprawdza się dostępność wszystkich dóbr.\n\t\t\tfor(var i = 0; i < goods.length; i++){\n\t\t\t\tvar productId = goods[i];\n\n\t\t\t\tvar type = TYPE_OK;\n\n\t\t\t\t// Przegląda się listę grup od tej najbogatszej - oni zawsze mają\n\t\t\t\t// dostęp do większej ilości produktów. Ci biedniejsi będą go więc mieć\n\t\t\t\t// automatycznie mniej do podziału - czyli wygenerują jakąś akcję.\n\t\t\t\tfor(var j = (island.houseGroups[0].length - 1); j >= 0; j--){ // <- index=0 is player index\n\t\t\t\t\tvar houseGroup = island.houseGroups[0][j];\n\n\t\t\t\t\tif(houseGroup.totalNumberOfPeople == 0)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// Gdyby arystokraci potrzebowali płótna (CLOTH_ID) można by przy pierwszym\n\t\t\t\t\t// undefiend wyjść z tej pętlni, ale potrzebują więc trzeba kontynuować.\n\t\t\t\t\tif(houseGroup.consumption[productId] == undefined)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tvar breakFor = false;\n\t\t\t\t\t\n\t\t\t\t\tswitch(typeof houseGroup.consumption[productId]){\n\t\t\t\t\t\tcase \"number\":\n\t\t\t\t\t\t\t\t// Jeśli jakaś grupa jest niezadowolona z ilości dostawanego towaru\n\t\t\t\t\t\t\t\t// to wygeneruj wiadomość o tym. Przerwij wykonywanie pętli bo ci \"niżej\"\n\t\t\t\t\t\t\t\t// będa tak samo niezadowoleni - bo są biedniejsi ;)\n\t\t\t\t\t\t\t\tif(houseGroup.contentByConsumption[productId] < 1){\n\t\t\t\t\t\t\t\t\ttype = TYPE_NEED;\n\t\t\t\t\t\t\t\t\tbreakFor = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase \"boolean\":\n\t\t\t\t\t\t\t\t// Jeśli nie ma surowca do levelupa to wygeneruj monit. I przerwij wykonywanie\n\t\t\t\t\t\t\t\t// bo (patrz tabelka wymagań) \"poniżej\" na pewno nikt nie będzie ich potrzebował.\n\t\t\t\t\t\t\t\tif(houseGroup.contentByConsumption[productId] < 1){\n\t\t\t\t\t\t\t\t\ttype = TYPE_DEMAND;\n\t\t\t\t\t\t\t\t\tbreakFor = true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tconsole.error(\"incorect type\");\n\t\t\t\t\t}\n\n\t\t\t\t\tif(breakFor)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsetState(island.id, productId, type);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tupdate: function(delta){\n\t\t\tisSomethingMissingInPlayerHouses();\n\n\t\t\tfor(var stateId in states){\n\t\t\t\tvar state = states[stateId];\n\n\t\t\t\tif(state.type == TYPE_OK)\n\t\t\t\t\tcontinue;\n\n\t\t\t\tstate.timeSinceLastCall += delta;\n\n\t\t\t\tif(state.timeSinceLastCall >= 10){\n\t\t\t\t\tswitch(state.type){\n\t\t\t\t\t\tcase TYPE_NEED:\n\t\t\t\t\t\t\t\tif(state.productId == FOOD_ID)\n\t\t\t\t\t\t\t\t\tconsole.log(\"Your people are starving!\");\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tconsole.log(\"There is not enought \" + products[state.productId].name + \"!\");\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase TYPE_DEMAND:\n\t\t\t\t\t\t\t\tconsole.log(\"You should provide \" + products[state.productId].name + \".\");\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tstate.timeSinceLastCall = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/graphics/analytics.js?");

/***/ }),

/***/ "./app/scripts/graphics/drawMethod.js":
/*!********************************************!*\
  !*** ./app/scripts/graphics/drawMethod.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\ndraw.js\n\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [!(function webpackMissingModule() { var e = new Error(\"Cannot find module 'text!../../imgs/atlas.json'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()), __webpack_require__(/*! ../logic */ \"./app/scripts/logic.js\"), __webpack_require__(/*! ../graphics/gameplayState */ \"./app/scripts/graphics/gameplayState.js\"), __webpack_require__(/*! ../graphics/layerManager */ \"./app/scripts/graphics/layerManager.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(atlasJSON, Logic, gameplayState, layerManager){\n\tvar atlas = JSON.parse(atlasJSON);\n\n\tvar flagProgress = {};\n\n\tfunction getFlagForTile(tile, delta){\n\t\tif(flagProgress[tile.index] == undefined)\n\t\t\tflagProgress[tile.index] = 0;\n\n\t\tflagProgress[tile.index] += delta * Logic.timeFlowSpeed * 4;\n\t\tvar flagNum = Math.floor((flagProgress[tile.index] % 8) + 1);\n\n\t\treturn \"redflag\" + flagNum;\n\t}\n\n\treturn function(delta, ctx, cameraPosition, getSourceImage, isColorpicking){ // TODO: przepisać to\n\t\tctx.clearRect(0, 0, window.innerWidth, window.innerHeight);\n\n\t\tvar porters = {}; // [porterPosition] -> porterType\n\n\t\t// update porters positions to display\n\t\tfor(var i = 0; i < civilianUnits.length; i++){\n\t\t\tvar porter = civilianUnits[i];\n\n\t\t\tif(!(porter instanceof Porter))\n\t\t\t\tcontinue;\n\n\t\t\tif(porter.position.x != -1 && porter.position.y != -1 && porter.isBusy)\n\t\t\t\tporters[tiles.index(porter.position)] = (porter.origin instanceof Marketplace ? 1 : 2);\n\t\t}\n\n\t\tvar screenSize = tiles.coords(ctx.canvas.width, ctx.canvas.height);\n\t\tvar screenMarginSize = 100;\n\n\t\tvar toDrawArray = [];\n\n\t\tvar toDrawBuildings = {};\n\t\tvar toDrawMoutains = {};\n\n\t\tvar margin = 0;\n\t\tif(isColorpicking)\n\t\t\tmargin = 0;\n\n\t\tvar posX, posY;\n\t\tfunction calculateTilePosition(x, y){\n\t\t\tposX = cameraPosition.x + x * -32 + y * 32;\n\t\t\tposY = cameraPosition.y + y * 16 + x * 16;\n\t\t}\n\n\t\t// TODO: rysować tylko widoczne tilesy...\n\t\tfor(var x = -margin; x < tiles.size.x + margin; x++){\n\t\t\tfor(var y = -margin; y < tiles.size.y + margin; y++){\n\t\t\t\tcalculateTilePosition.call(this, x, y);\n\n\t\t\t\tvar outOfScreen = (posX < -screenMarginSize || posY < -screenMarginSize || posX > (screenSize.x + screenMarginSize) || posY > (screenSize.y + screenMarginSize));\n\n\t\t\t\tfunction drawRawAtlasTile(atlasName, modeName){\n\t\t\t\t\ttoDrawArray.push({\n\t\t\t\t\t\tatlasName: atlasName,\n\t\t\t\t\t\tx: x,\n\t\t\t\t\t\ty: y,\n\t\t\t\t\t\tscreenX: posX,\n\t\t\t\t\t\tscreenY: posY,\n\t\t\t\t\t\tisVisible: !outOfScreen,\n\t\t\t\t\t\tspecialMode: modeName\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tfunction drawAtlasTile(atlasName, tile, mode){\n\t\t\t\t\tdrawRawAtlasTile(atlasName, mode);\n\n\t\t\t\t\tif(tile != undefined){\n\t\t\t\t\t\tif(!outOfScreen && tile.buildingData != null)\n\t\t\t\t\t\t\ttoDrawBuildings[tile.buildingData.structureId] = true;\n\n\t\t\t\t\t\tif(!outOfScreen && tile.terrainLevel >= HILLSIDE && tile.terrainType != undefined)\n\t\t\t\t\t\t\ttoDrawMoutains[tiles.index(tile.terrainType)] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ~~~\n\n\t\t\t\tif(!tiles.exsist(x, y)){\n\t\t\t\t\tif(!outOfScreen)\n\t\t\t\t\t\tdrawAtlasTile(\"sea1\", undefined);\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tvar tile = tiles[x][y];\n\t\t\t\tvar tileImage = \"\";\n\n\t\t\t\tif(outOfScreen){\n\t\t\t\t\tif(!(tile.terrainLevel >= HILLSIDE ||\n\t\t\t\t\t\t(tile.buildingData != undefined && tile.buildingData.width > 1 && tile.buildingData.height > 1)))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// (1) teren:\n\n\t\t\t\tfunction buildSpecialTileName(name, hash){\n\t\t\t\t\tfunction getTile(x, y){\n\t\t\t\t\t\tif(tiles[x] == undefined || tiles[x][y] == undefined)\n\t\t\t\t\t\t\treturn (new Tile());\n\n\t\t\t\t\t\treturn tiles[x][y];\n\t\t\t\t\t}\n\n\t\t\t\t\treturn name +\t\"_\" + hash(getTile(x + 1, y)) +\n\t\t\t\t\t\t\t\t\t\"_\" + hash(getTile(x, y + 1)) +\n\t\t\t\t\t\t\t\t\t\"_\" + hash(getTile(x - 1, y)) +\n\t\t\t\t\t\t\t\t\t\"_\" + hash(getTile(x, y - 1));\n\t\t\t\t}\n\n\t\t\t\tswitch(tile.terrainLevel){\n\t\t\t\t\tcase SEA:\n\t\t\t\t\t\t\ttileImage = \"sea1\";\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase SHALLOW:\n\t\t\t\t\t\t\ttileImage = buildSpecialTileName(\"shallow1\", function(tile){\n\t\t\t\t\t\t\t\tswitch(tile.terrainLevel){\n\t\t\t\t\t\t\t\t\tcase 0: return 'h';\n\t\t\t\t\t\t\t\t\tcase 1: return 'c';\n\t\t\t\t\t\t\t\t\tdefault: return 's';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase COAST:\n\t\t\t\t\t\t\ttileImage = buildSpecialTileName(\"coast1\", function(tile){\n\t\t\t\t\t\t\t\tswitch(tile.terrainLevel){\n\t\t\t\t\t\t\t\t\tcase 0: return 's';\n\t\t\t\t\t\t\t\t\tcase 1: return 'c';\n\t\t\t\t\t\t\t\t\tdefault: return 'i';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase PLAINS:\n\t\t\t\t\t\t\ttileImage = \"grassland1\";\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase HILLSIDE:\n\t\t\t\t\t\t\ttileImage = buildSpecialTileName(\"hillside1\", function(tile){\n\t\t\t\t\t\t\t\tswitch(tile.terrainLevel){\n\t\t\t\t\t\t\t\t\tcase 3: return 'h';\n\t\t\t\t\t\t\t\t\tcase 4: return 'm';\n\t\t\t\t\t\t\t\t\tdefault: return 'i';\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase MOUTAIN:\n\t\t\t\t\t\t\tvar localX = x - tile.terrainType.x;\n\t\t\t\t\t\t\tvar localY = y - tile.terrainType.y;\n\n\t\t\t\t\t\t\ttileImage = \"moutain1_\" + localX + \"_\" + localY;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// tilesy wyspy są na wyższym poziomie niż reszta :)\n\t\t\t\tif(tile.terrainLevel >= PLAINS)\n\t\t\t\t\tposY -= 20;\n\n\t\t\t\t// (2) budynek:\n\n\t\t\t\tfunction getBuildingImage(building, offset){\n\t\t\t\t\tvar name = _.clone(building.structName).replace(/\\s/g, '');\n\t\t\t\t\tname = name.toLowerCase();\n\n\t\t\t\t\tif(building instanceof FieldPlant)\n\t\t\t\t\t\tname = name + (building.isWithered ? \"withered\" : \"\");\n\n\t\t\t\t\tif(building instanceof House)\n\t\t\t\t\t\tname = name + (building.type + 1).toString(); // house<level>_...\n\t\t\t\t\telse\n\t\t\t\t\t\tname = name + Math.floor(building.rotation / 10); // <buildingname><side>\n\n\t\t\t\t\tswitch(building.structName){\n\t\t\t\t\t\tcase \"Road\":\n\t\t\t\t\t\t\treturn buildSpecialTileName(name, function(tile){\n\t\t\t\t\t\t\t\treturn (tile.buildingData instanceof Road ? 'r' : 'n');\n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn name + \"_\" + offset.x + \"_\" + offset.y;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar canBeOverwritten = true;\n\n\t\t\t\tif(tile.buildingData != null){\n\t\t\t\t\ttileImage = getBuildingImage(tile.buildingData, tile.buildingData.isUnder(tile));\n\t\t\t\t\tcanBeOverwritten = tile.buildingData.canBeOverwritten;\n\t\t\t\t}\n\n\t\t\t\t// (3) ew. budynek testowego (budowanie budynku):\n\n\t\t\t\tvar wasOverwrittenByTestBuilding = false;\n\n\t\t\t\tif(!isColorpicking){\n\t\t\t\t\tif( gameplayState.buildMode && gameplayState.testBuilding != undefined &&\n\t\t\t\t\t\tgameplayState.hoveredTile != undefined && canBeOverwritten && tile.islandId != INVALID_ID ){\n\n\t\t\t\t\t\tfor(var i = 0; i < gameplayState.buildingsToPlacement.length; i++){\n\t\t\t\t\t\t\tvar buildingCoords = gameplayState.buildingsToPlacement[i];\n\n\t\t\t\t\t\t\tvar offsetX = Math.floor((gameplayState.testBuilding.width - 1) / 2);\n\t\t\t\t\t\t\tvar offsetY = Math.floor((gameplayState.testBuilding.height - 1) / 2);\n\n\t\t\t\t\t\t\tvar localX = x - buildingCoords.x + offsetX;\n\t\t\t\t\t\t\tvar localY = y - buildingCoords.y + offsetY;\n\n\t\t\t\t\t\t\tif( localX >= 0 && localX < gameplayState.testBuilding.width &&\n\t\t\t\t\t\t\t\tlocalY >= 0 && localY < gameplayState.testBuilding.height ){\n\t\t\t\t\t\t\t\ttileImage = getBuildingImage(gameplayState.testBuilding, tiles.coords(localX, localY));\n\t\t\t\t\t\t\t\twasOverwrittenByTestBuilding = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// ~~~\n\n\t\t\t\tif(tileImage != undefined){\n\t\t\t\t\t// special drawing for special modes:\n\n\t\t\t\t\tvar mode = \"base\";\n\n\t\t\t\t\tif((gameplayState.buildMode || gameplayState.removeMode) && tile.countryId != 0)\n\t\t\t\t\t\tmode = \"darkner\";\n\n\t\t\t\t\tif(gameplayState.hoveredTile != undefined &&\n\t\t\t\t\t   tiles.at_mayRetEmpty(gameplayState.hoveredTile).buildingData != undefined &&\n\t\t\t\t\t   tiles.at_mayRetEmpty(gameplayState.hoveredTile).buildingData == tile.buildingData)\n\t\t\t\t\t\tmode = \"lighter_1\";\n\t\t\t\t\t\n\t\t\t\t\tif(gameplayState.buildMode && wasOverwrittenByTestBuilding)\n\t\t\t\t\t\t\tmode = \"oranger\";\n\n\t\t\t\t\tif(gameplayState.removeMode){\n\t\t\t\t\t\t// TODO: przepisać gameplayState.buildingsToPlacement by wyeliminować tą funkcję\n\t\t\t\t\t\t// ona zżera masę czasu procesora.\n\t\t\t\t\t\tfor(var i = 0; i < gameplayState.buildingsToPlacement.length; i++)\n\t\t\t\t\t\t\tif(tile.buildingData === tiles.at_mayRetEmpty(gameplayState.buildingsToPlacement[i]).buildingData)\n\t\t\t\t\t\t\t\tmode = \"red\";\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tdrawAtlasTile(tileImage, tile, mode);\n\t\t\t\t}\n\n\t\t\t\t// draw porter, if any\n\t\t\t\tif(porters[tile.index] != undefined)\n\t\t\t\t\tdrawRawAtlasTile(\"placeholder_porter\" + porters[tile.index]);\n\n\t\t\t\t/*\n\t\t\t\t// draw flag, if any\n\t\t\t\tif(tile.buildingData != null && tile.buildingData instanceof Port &&\n\t\t\t\t\ttiles.index(tile.buildingData.southTile()) == tiles.index(tile)){\n\n\t\t\t\t\tposY -= 80;\n\t\t\t\t\tposX += 16;\n\n\t\t\t\t\tdrawRawAtlasTile(getFlagForTile(tile, delta));\n\t\t\t\t}\n\t\t\t\telse if(tile.buildingData != null && tile.buildingData instanceof Marketplace &&\n\t\t\t\t\ttiles.index(tile.buildingData.southTile()) == tiles.index(tile)){\n\n\t\t\t\t\tposY -= 90;\n\t\t\t\t\tposX += 25;\n\n\t\t\t\t\tdrawRawAtlasTile(getFlagForTile(tile, delta));\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\n\t\tfor(var j = 0; j < militaryUnits.length; j++){\n\t\t\tvar ship = militaryUnits[j];\n\n\t\t\tif(ship == undefined)\n\t\t\t\tcontinue;\n\n\t\t\tcalculateTilePosition.call(this, ship.position.x, ship.position.y);\n\n\t\t\tvar shipXMovement = ship.rotationVector.x * ((ship.lastMoveTime) / 1);\n\t\t\tvar shipYMovement = ship.rotationVector.y * ((ship.lastMoveTime) / 1);\n\n\t\t\tposX += (shipXMovement * -32 + shipYMovement * 32);\n\t\t\tposY += (shipYMovement * 16 + shipXMovement * 16);\n\n\t\t\tvar x = ship.position.x;\n\t\t\tvar y = ship.position.y;\n\n\t\t\tdrawRawAtlasTile(\"ship_smalltrade_\" + ship.rotation);\n\n\t\t\t// zaznacz jakoś że statek jest zaznaczony\n\t\t\tif(ship === gameplayState.choosedSth && !isColorpicking){\n\t\t\t\tdrawAtlasTile(\"ship_smalltrade_\" + ship.rotation, tile, \"lighter_3\");\n\t\t\t}\n\n\t\t\tposY -= 64;\n\t\t\tposX += 0;\n\n\t\t\tdrawRawAtlasTile(getFlagForTile(tiles.at(ship.position), delta));\n\t\t}\n\n\t\t// faktyczne wyświetlanie\n\t\tfor(var i = 0; i < toDrawArray.length; i++){\n\t\t\tvar item = toDrawArray[i];\n\n\t\t\t// aby narysować budynek trzeba sprawdzić czy którykolwiek z jego tilesów\n\t\t\t// znajduje sie na iloście obiektów do narysowania (by go nie rysować gdy jest poza planszą)\n\t\t\tif(tiles.exsist(item.x, item.y)){\n\t\t\t\tvar tile = tiles[item.x][item.y];\n\n\t\t\t\tif(tile != undefined){\n\t\t\t\t\tif(tile.buildingData != null &&\n\t\t\t\t\t\t!(tile.buildingData.structureId in toDrawBuildings))\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tif(tile.terrainLevel >= HILLSIDE && tile.terrainType != undefined &&\n\t\t\t\t\t\t!(tiles.index(tile.terrainType) in toDrawMoutains))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar coords = atlas[item.atlasName];\n\n\t\t\tif(coords == undefined)\n\t\t\t\tcontinue;\n\n\t\t\t// rysuje się zawsze od początku tilesa\n\t\t\tvar x = item.screenX - Math.floor(coords.w / 2);\n\t\t\tvar y = item.screenY - coords.h;\n\n\t\t\tfunction drawImage(item, coords, layerName){\n\t\t\t\tctx.drawImage(\n\t\t\t\t\tgetSourceImage(layerName, item),\n\t\t\t\t\tcoords.x, coords.y, coords.w, coords.h,\n\t\t\t\t\tx, y, coords.w, coords.h\n\t\t\t\t);\n\t\t\t};\n\n\t\t\t// nie używa się specjalnych operacji podczas colorpickingu\n\t\t\tdrawImage(item, coords, (item.specialMode != undefined && !isColorpicking ? item.specialMode : \"base\"));\n\t\t}\n\t};\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/graphics/drawMethod.js?");

/***/ }),

/***/ "./app/scripts/graphics/framework.js":
/*!*******************************************!*\
  !*** ./app/scripts/graphics/framework.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\nframework.js\n\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"), __webpack_require__(/*! three-stats */ \"./node_modules/three-stats/dist/index.js\"), __webpack_require__(/*! jquery-mousewheel */ \"./node_modules/jquery-mousewheel/jquery.mousewheel.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function($, Stats){\n\tfunction initFpsCounter(){\n\t\tvar stats = new Stats();\n\t\tstats.setMode(0); // 0: fps, 1: ms\n\n\t\t// Align top-left\n\t\tstats.domElement.style.position = 'absolute';\n\t\tstats.domElement.style.right = '100px';\n\t\tstats.domElement.style.top = '0px';\n\n\t\t$(\"#on_canvas\").append(stats.domElement);\n\n\t\treturn stats;\n\t}\n\n\treturn function(wrapper){\n\t\tconsole.assert(typeof wrapper === \"object\");\n\n\t\twrapper.resources = wrapper.resources || [];\n\t\twrapper.loadedResources = {};\n\n\t\twrapper.fullscreen = wrapper.fullscreen || false;\n\n\t\twrapper.onUpdate = wrapper.onUpdate || function(){};\n\t\twrapper.onRender = wrapper.onRender || function(){};\n\t\twrapper.onLoadResources = wrapper.onLoadResources || function(){};\n\n\t\twrapper.onKeyDown = wrapper.onKeyDown || function(){};\n\t\twrapper.onKeyUp = wrapper.onKeyUp || function(){};\n\n\t\twrapper.onMouseEnter = wrapper.onMouseEnter || function(){};\n\t\twrapper.onMouseLeave = wrapper.onMouseLeave || function(){};\n\t\twrapper.onMouseMove = wrapper.onMouseMove || function(){};\n\t\twrapper.onMouseDown = wrapper.onMouseDown || function(){};\n\t\twrapper.onMouseUp = wrapper.onMouseUp || function(){};\n\t\twrapper.onMouseWheel = wrapper.onMouseWheel || function(){};\n\n\t\twrapper.onMouseClick = wrapper.onMouseClick || function(){};\n\n\t\t// ~~~\n\n\t\tthis._ = wrapper;\n\n\t\tthis.stats = initFpsCounter();\n\n\t\t// ~~~\n\n\t\tvar loadedResourcesCount = 0;\n\n\t\tthis.canvas = $(\"#mainCanvas\");\n\n\t\tvar context = $(this.canvas)[0].getContext(\"2d\");\n\n\t\tif(wrapper.fullscreen){\n\t\t\tcontext.canvas.width = parseInt($(\"body\").width());\n\t\t\tcontext.canvas.height = parseInt(window.innerHeight);\n\t\t}\n\n\t\t$(window).resize(function(){\n\t\t\tcontext.canvas.width = parseInt($(\"body\").width());\n\t\t\tcontext.canvas.height = parseInt(window.innerHeight);\n\t\t});\n\n\t\tvar oldTime = (new Date()).getTime();\n\t\tvar newTime = 0;\n\t\tvar delta = 0;\n\n\t\tvar X = 0;\n\t\tvar Y = 0;\n\n\t\tvar wasMouseCursorMovedSinceMouseDown = false;\n\t\tvar lastMouseDown = 0;\n\n\t\t$(\"body\").keydown(function(e){ wrapper.onKeyDown.call(wrapper, e.which); });\n\t\t$(\"body\").keyup(function(e){ wrapper.onKeyUp.call(wrapper, e.which); });\n\n\t\t$(this.canvas).mouseenter($.proxy(wrapper.onMouseEnter, wrapper));\n\t\t$(this.canvas).mouseleave($.proxy(wrapper.onMouseLeave, wrapper));\n\t\t\n\t\t$(this.canvas).mousemove($.proxy(function(e){\n\t\t\tX = e.pageX - $(this.canvas).offset().left;\n\t\t\tY = e.pageY - $(this.canvas).offset().top;\n\n\t\t\twasMouseCursorMovedSinceMouseDown = true;\n\n\t\t\twrapper.onMouseMove.call(wrapper, X, Y);\n\t\t}, this));\n\t\t\n\t\t$(this.canvas).mousedown(function(){\n\t\t\twasMouseCursorMovedSinceMouseDown = false;\n\t\t\tlastMouseDown = (new Date()).getTime();\n\n\t\t\twrapper.onMouseDown.call(wrapper, X, Y);\n\t\t});\n\t\t\n\t\t$(this.canvas).mouseup(function(){\n\t\t\twrapper.onMouseUp.call(wrapper, X, Y);\n\n\t\t\tif(!wasMouseCursorMovedSinceMouseDown || ((new Date()).getTime() - lastMouseDown) < 200)\n\t\t\t\twrapper.onMouseClick.call(wrapper, X, Y);\n\t\t});\n\n\t\t$(this.canvas).mousewheel(function(e){ wrapper.onMouseWheel.call(wrapper, e.deltaY); });\n\n\t\tthis.step = $.proxy(function(){\n\t\t\tnewTime = (new Date()).getTime();\n\t\t\tdelta = (newTime - oldTime) / 1000;\n\n\t\t\tthis.stats.begin();\n\n\t\t\twrapper.onUpdate(delta);\n\t\t\twrapper.onRender(delta, context, wrapper.loadedResources);\n\n\t\t\tthis.stats.end();\n\n\t\t\toldTime = newTime;\n\n\t\t\trequestAnimationFrame(this.step);\n\t\t}, this);\n\n\t\tthis.start = function(){\n\t\t\tconsole.log('starting loading requested ' + wrapper.resources.length + ' image(s)');\n\n\t\t\tfor(var i = 0; i < wrapper.resources.length; i++){\n\t\t\t\tvar name = wrapper.resources[i];\n\n\t\t\t\twrapper.loadedResources[name] = new Image(); // TODO: Uwolnić resources od bycia stricte Image.\n\n\t\t\t\twrapper.loadedResources[name].onload = $.proxy(function(){\n\t\t\t\t\tloadedResourcesCount++;\n\t\t\t\t\tif(loadedResourcesCount >= wrapper.resources.length){\n\t\t\t\t\t\tconsole.log('...done loading images, lauching game');\n\n\t\t\t\t\t\twrapper.onLoadResources(wrapper.loadedResources);\n\n\t\t\t\t\t\toldTime = (new Date()).getTime();\n\t\t\t\t\t\trequestAnimationFrame(this.step);\n\t\t\t\t\t}\n\t\t\t\t}, this);\n\n\t\t\t\twrapper.loadedResources[name].src = \"imgs/\" + name + \".png\";\n\t\t\t}\n\t\t};\n\t};\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/graphics/framework.js?");

/***/ }),

/***/ "./app/scripts/graphics/gameplayState.js":
/*!***********************************************!*\
  !*** ./app/scripts/graphics/gameplayState.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\ngameplayState.js\n\n*/\n\nvar gameplayState = {\n\t// aktualna pozycja kamery\n\tcameraPosition: {\n\t\t\tx: 500,\n\t\t\ty: 0\n\t\t},\n\n\t// czy poruszamy kamerą gry\n\tmoveMap: false,\n\n\t// czy wybrano jakiś budynek do wybudowania\n\tbuildMode: false,\n\n\t// wybrany budynek do wybudowania gdy się kliknie w miejsce które pozwala go wybudować\n\ttestBuilding: undefined,\n\n\t// testBuilding powielone na obszar wyznaczony przez przeciągnięcie myszką\n\tbuildingsToPlacement: [],\n\n\t// czy używamy przeciągania (jeżeli nie używamy przeciągania to używa się po prostu clik-to-build)\n\tuseWidePlacement: false,\n\n\t// obszar wyznaczony myszką po kliknięciu w trybie buildMode\n\tplacementRectangle: {\n\t\tbegin: undefined,\n\t\tend: undefined\n\t},\n\n\t// tryb gdzie kliknięcie w budynek oznacza jego usunięcie\n\tremoveMode: false,\n\t\n\t// tile nad którym aktualnie znajduje się kursor\n\thoveredTile: undefined,\n\n\t// cokolwiek klikniętego przez usera (może to być budynek, statek, etc.)\n\tchoosedSth: undefined,\n\n\t// id budynku ponad którym jest myszka w build mode\n\tbuildMenuHover: undefined,\n\n\t// dla gui.js (usunąć to stąd!)\n\tguiClickHandler: function(){}\n};\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){\n\treturn gameplayState;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))\n\n//# sourceURL=webpack:///./app/scripts/graphics/gameplayState.js?");

/***/ }),

/***/ "./app/scripts/graphics/gui/directives.js":
/*!************************************************!*\
  !*** ./app/scripts/graphics/gui/directives.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\ndirectives.js\n\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! angular */ \"./node_modules/angular/index.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(angular){\n\tvar directives = angular.module(\"directives\", []);\n\n\tfunction makeBuildingImageLink(input){\n\t\tif(input == undefined || input.length == 0)\n\t\t\tinput = \"unknown\";\n\n\t\tvar name = input.replace(/\\s/g, '');\n\t\tname = name.toLowerCase();\n\n\t\tif(name == \"port\")\n\t\t\tname += \"1\";\n\n\t\tvar image = 'imgs/gui/buildings/' + name + '.png';\n\t\treturn image;\n\t}\n\n\tdirectives.directive(\"buildingImage\", function(){\n\t\treturn {\n\t\t\tscope: {\n\t\t\t\timgName: \"=name\"\n\t\t\t},\n\t\t\tlink: function(scope){\n\t\t\t\tscope.$watch('imgName', function(){\n\t\t\t\t\tscope.imgSrc = makeBuildingImageLink(scope.imgName);\n\t\t\t\t});\n\t\t\t},\n\t\t\treplace: true,\n\t\t\ttemplateUrl: 'views/image.html'\n\t\t};\n\t});\n\n\t// ~~~\n\n\tfunction makeProductImageLink(input){\n\t\tif(input == undefined)\n\t\t\treturn 'imgs/gui/products/empty.png';\n\n\t\tvar productId = parseInt(input);\n\t\tvar productName = products[productId].name;\n\n\t\tvar name = productName.replace(/\\s/g, '');\n\t\tname = name.toLowerCase();\n\n\t\tvar image = 'imgs/gui/products/' + name + '.png';\n\t\treturn image;\n\t};\n\n\tdirectives.directive(\"productImage\", function(){\n\t\treturn {\n\t\t\tscope: {\n\t\t\t\timgName: \"=name\"\n\t\t\t},\n\t\t\tlink: function(scope){\n\t\t\t\tscope.$watch('imgName', function(){\n\t\t\t\t\tscope.imgSrc = makeProductImageLink(scope.imgName);\n\t\t\t\t});\n\t\t\t},\n\t\t\treplace: true,\n\t\t\ttemplateUrl: 'views/image.html'\n\t\t};\n\t});\n\n\tfunction makeGoodsImageLink(input){\n\t\tif(input == undefined)\n\t\t\treturn 'imgs/gui/products/empty.png';\n\n\t\tvar productId = parseInt(input);\n\t\tvar productName = products[productId].name;\n\n\t\tvar name = productName.replace(/\\s/g, '');\n\t\tname = name.toLowerCase();\n\n\t\tvar image = 'imgs/gui/' + name + '.png';\n\t\treturn image;\n\t};\n\n\tdirectives.directive(\"goodsImage\", function(){\n\t\treturn {\n\t\t\tscope: {\n\t\t\t\timgName: \"=name\"\n\t\t\t},\n\t\t\tlink: function(scope){\n\t\t\t\tscope.$watch('imgName', function(){\n\t\t\t\t\tscope.imgSrc = makeGoodsImageLink(scope.imgName);\n\t\t\t\t});\n\t\t\t},\n\t\t\treplace: true,\n\t\t\ttemplateUrl: 'views/image.html'\n\t\t};\n\t});\n\n\tfunction makeRawGuiImage(input){\n\t\tif(input == undefined)\n\t\t\treturn 'imgs/gui/products/empty.png';\n\n\t\tvar name = input.replace(/\\s/g, '');\n\t\tname = name.toLowerCase();\n\n\t\tvar image = 'imgs/gui/' + name + '.png';\n\t\treturn image;\n\t};\n\n\tdirectives.directive(\"rawGuiImage\", function(){\n\t\treturn {\n\t\t\tscope: {\n\t\t\t\timgName: \"=name\"\n\t\t\t},\n\t\t\tlink: function(scope){\n\t\t\t\tscope.$watch('imgName', function(){\n\t\t\t\t\tscope.imgSrc = makeRawGuiImage(scope.imgName);\n\t\t\t\t});\n\t\t\t},\n\t\t\treplace: true,\n\t\t\ttemplateUrl: 'views/image.html'\n\t\t};\n\t});\n\n\t// ~~~\n\n\tdirectives.directive(\"buildingDialog\", function(){\n\t\treturn {\n\t\t\ttransclude: true,\n\t\t\ttemplateUrl: 'views/buildingDialog.html',\n\t\t\tscope: {},\n\t\t\tlink: function(scope, element, attrs, foo, transclude) {\n\t\t\t\telement.addClass(\"buildingDialog\");\n\t\t\t\tscope.close = function(){ $(element).hide(); }\n\n\t\t\t\ttransclude(scope.$parent, function(content) {\n\t\t\t\t\telement.children('div.content').html(content);\n\t\t\t\t});\n\n\t\t\t\tscope.$parent.$watch('building', function(){\n\t\t\t\t\tscope.building = scope.$parent.building;\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\t});\n\t\n\treturn directives;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/graphics/gui/directives.js?");

/***/ }),

/***/ "./app/scripts/graphics/gui/gui.js":
/*!*****************************************!*\
  !*** ./app/scripts/graphics/gui/gui.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\ngui.js\n\nDodać tutuaj listę kontrolerów do update i updateować jak wszystko inne.\n\nTODO: Usunąć \"guiClickHandler\" - gui.js ma być jedynie odzwierciedleniem stanu graphics.js\na nie samemu wpływać na ten stan...\n\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! angular */ \"./node_modules/angular/index.js\"), __webpack_require__(/*! ../../graphics */ \"./app/scripts/graphics.js\"), __webpack_require__(/*! ../../logic */ \"./app/scripts/logic.js\"), __webpack_require__(/*! ../../graphics/gameplayState */ \"./app/scripts/graphics/gameplayState.js\"), __webpack_require__(/*! extend */ \"./app/externals/extend.js\"), __webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\"), __webpack_require__(/*! ../../graphics/gui/directives */ \"./app/scripts/graphics/gui/directives.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(angular, graphics, logic, gameplayState){\n\t// niestety angular sam nie updateuje zmian z \"other sources\"\n\t// więc trzeba samemu callować zmianę $scopa co jakiś czas\n\tfunction registerInfiniteUpdate(scope, func){\n\t\t// natychmiastowy update\n\t\tfunc();\n\n\t\t// następne co jakiś interwał czasowy\n\t\tsetInterval(function(){ scope.$apply(func); }, 100);\n\t}\n\n\t// ~~~\n\n\t// jebane centrowanie elementów w CSS nigdy kurwa nie działa jak bym chciał\n\t$(\"#top_center\").css(\"margin-left\", -($(\"#top_center\").width() / 2) + \"px\");\n\n\tvar app = angular.module(\"app\", [\"directives\"]);\n\n\tapp.controller(\"CoinsViewer\", function($scope){\n\t\tregisterInfiniteUpdate($scope, function(){\n\t\t\t$scope.coins = countries[0].coins;\n\t\t});\n\t});\n\n\tapp.controller(\"OwnedIslandResourcesViewer\", function($scope){\n\t\tregisterInfiniteUpdate($scope, function(){\n\t\t\t$scope.hoverOnIsland = (gameplayState.hoveredTile != undefined) && (gameplayState.hoveredTile.countryId != INVALID_ID);\n\t\t\tif($scope.hoverOnIsland){\n\t\t\t\tvar island = islands[gameplayState.hoveredTile.islandId];\n\n\t\t\t\t$scope.tool = island.mainMarketplaces[0].storage.of(TOOLS_ID);\n\t\t\t\t$scope.wood = island.mainMarketplaces[0].storage.of(WOOD_ID);\n\t\t\t\t$scope.brick = island.mainMarketplaces[0].storage.of(BRICKS_ID);\n\t\t\t}\n\t\t});\n\t});\n\n\tapp.controller(\"IslandPopulationViewer\", function($scope){\n\t\tregisterInfiniteUpdate($scope, function(){\n\t\t\t$scope.hoverOnIsland = (gameplayState.hoveredTile != undefined) && (gameplayState.hoveredTile.countryId != INVALID_ID);\n\t\t\tif($scope.hoverOnIsland){\n\t\t\t\tvar houseGroups = islands[gameplayState.hoveredTile.islandId].houseGroups[0];\n\n\t\t\t\t$scope.population = 0;\n\t\t\t\tif(houseGroups != undefined){\n\t\t\t\t\tfor(var i = 0; i < houseGroups.length; i++){\n\t\t\t\t\t\t$scope.population += houseGroups[i].totalNumberOfPeople;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t});\n\n\t// ~~~\n\n\tapp.controller(\"TimeCtrl\", function($scope){\n\t\t$scope.timeController = logic;\n\t});\n\n\t// ~~~\n\n\tvar buildingDlgs = {\n\t\t\"#HouseDlg\": \"#HouseDlg\",\n\t\t\"#MarketplaceDlg\": \"#MarketplaceDlg\",\n\t\t\"#ProductionBuildingDlg\": \"#ProductionBuildingDlg\"\n\t};\n\n\tgameplayState.guiClickHandler = function(x, y){\n\t\t// showBuildingDlg\n\t\tif(gameplayState.choosedSth == undefined || !(gameplayState.choosedSth instanceof Building))\n\t\t\treturn;\n\n\t\tvar structName = gameplayState.choosedSth.structName;\n\n\t\tif(gameplayState.choosedSth instanceof Port)\n\t\t\tstructName = \"Marketplace\";\n\n\t\tif(gameplayState.choosedSth instanceof ProductionBuilding)\n\t\t\tstructName = \"ProductionBuilding\";\n\n\t\tvar id = (\"#\" + structName + \"Dlg\");\n\n\t\tif(buildingDlgs[id] === undefined)\n\t\t\treturn;\n\n\t\t// closeAllBuildingsDlgs\n\t\t$.each(buildingDlgs, function(i, v){\n\t\t\t$(v).hide();\n\t\t});\n\n\t\t$(id).show();\n\n\t\t$(id).scope().$apply(function($scope){\n\t\t\t$scope.building = undefined;\n\t\t});\n\n\t\t$(id).scope().$apply(function($scope){\n\t\t\t$scope.building = gameplayState.choosedSth;\n\t\t});\n\t};\n\n\tapp.controller(\"HouseCtrl\", function($scope){\n\t\t$scope.building = undefined;\n\n\t\t$scope.requiredMasks = __publicBuildingsMask__;\n\n\t\t$scope.$watch('building', function(){\n\t\t\tif($scope.building === undefined)\n\t\t\t\treturn;\n\n\t\t\t$scope.underTile = $scope.building.centerTile();\n\n\t\t\tvar island = islands[$scope.underTile.islandId];\n\t\t\tvar country = countries[$scope.underTile.countryId];\n\n\t\t\t$scope.houseGroup = island.houseGroups[country.id][$scope.building.type];\n\n\t\t\t$scope.isMaskNotFulfilled = function(mask){\n\t\t\t\treturn ($scope.houseGroup.requiredPublicBuildingsMask & mask) && !($scope.underTile.publicBuildingMask & mask);\n\t\t\t}\n\t\t});\n\t});\n\n\tapp.controller(\"MarketplaceCtrl\", function($scope){\n\t\t$scope.building = undefined;\n\n\t\t$scope.island = undefined;\n\t\t$scope.country = undefined;\n\n\t\t$scope.storage = {};\n\t\t$scope.productsLookup = products;\n\n\t\t$scope.$watch('building', function(){\n\t\t\tif($scope.building === undefined)\n\t\t\t\treturn;\n\n\t\t\t$scope.island = islands[$scope.building.centerTile().islandId];\n\t\t\t$scope.country = countries[$scope.building.centerTile().countryId];\n\n\t\t\t$scope.storage = $scope.island.mainMarketplaces[$scope.country.id].storage.slots;\n\t\t});\n\t});\n\n\tapp.controller(\"ProductionBuildingCtrl\", function($scope){\n\t\t$scope.building = undefined;\n\n\t\t$scope.storage = {};\n\t\t$scope.productsLookup = products;\n\n\t\t$scope.$watch('building', function(){\n\t\t\tif($scope.building === undefined)\n\t\t\t\treturn;\n\n\t\t\t$scope.storage = $scope.building.storage.slots;\n\t\t});\n\t});\n\n\t// ~~~\n\n\tapp.controller(\"BuildCtrl\", function($scope){\n\t\t$scope.callback = gameplayState;\n\t\t\n\t\t$scope.choosedBuilding = -1;\n\t\t$scope.allBuildings = structsClass.slice(1, structsClass.length);\n\n\t\t$scope.beginHoverBuilding = function(){\n\t\t\tvar index = INVALID_ID;\n\t\t\tif(this.building != undefined)\n\t\t\t\tindex = this.building.index;\n\n\t\t\tindex = parseInt(index);\n\n\t\t\tvar structure = structsClass[index];\n\t\t\tgameplayState.buildMenuHover = new structure.class(0, 0, null, undefined);\n\t\t\tgameplayState.buildMenuHover.onBuild();\n\t\t};\n\n\t\t$scope.endHoverBuilding = function(){\n\t\t\tgameplayState.buildMenuHover = undefined;\n\t\t};\n\n\t\t$scope.toggleRemoveMode = function(){\n\t\t\t$scope.callback.buildMode = false;\n\t\t\t$scope.callback.removeMode = !$scope.callback.removeMode;\n\n\t\t\t$scope.choosedBuilding = -1;\n\t\t\t\n\t\t\t$scope.callback.testBuilding = undefined;\n\t\t};\n\n\t\t$scope.buildModeStateChange = function(){\n\t\t\t$scope.callback.buildMode = false;\n\t\t\t$scope.callback.removeMode = false;\n\n\t\t\t$scope.callback.moveMap = false;\n\n\t\t\t$scope.choosedBuilding = -1;\n\n\t\t\t$scope.callback.testBuilding = undefined;\n\t\t};\n\n\t\t$scope.chooseBuilding = function(){\n\t\t\t$scope.callback.buildMode = true;\n\t\t\t$scope.callback.removeMode = false;\n\n\t\t\tif(this.building != undefined)\n\t\t\t\t$scope.choosedBuilding = this.building.index;\n\n\t\t\tvar choosed = parseInt($scope.choosedBuilding);\n\n\t\t\t$scope.side = NORTH;\n\t\t\tif($scope.callback.testBuilding != undefined && choosed === $scope.callback.testBuilding.index)\n\t\t\t\t$scope.side = $scope.callback.testBuilding.rotation;\n\t\t\t\n\t\t\tif(choosed >= 0){\n\t\t\t\tvar structure = structsClass[choosed];\n\t\t\t\t\n\t\t\t\t$scope.callback.testBuilding = new structure.class(0, 0, null, undefined, $scope.side);\n\n\t\t\t\t$scope.callback.testBuilding.onBuild();\n\n\t\t\t\t$scope.callback.testBuilding.index = choosed;\n\t\t\t}\n\t\t};\n\n\t\t$scope.callback.showBuildMenu = false;\n\t\t$scope.toggleBuildMenu = function(){\n\t\t\t$scope.callback.showBuildMenu = !$scope.callback.showBuildMenu;\n\t\t\t$scope.buildModeStateChange();\n\t\t};\n\t});\n\n\tapp.filter('rotationLetterByCode', function(){\n\t\treturn function(input){\n\t\t\tswitch(parseInt(input)){\n\t\t\t\tcase NORTH: return 'N';\n\t\t\t\tcase SOUTH: return 'S';\n\t\t\t\tcase EAST: return 'E';\n\t\t\t\tcase WEST: return 'W';\n\t\t\t\tdefault: return '?';\n\t\t\t}\n\t\t};\n\t});\n\n\tapp.filter('contentImageSrc', function(){\n\t\treturn function(input){\n\t\t\tswitch(parseInt(input)){\n\t\t\t\tcase VERY_WEALTHY:\n\t\t\t\tcase WEALTHY:\n\t\t\t\t\treturn \"imgs/gui/citizen_happy.png\";\n\n\t\t\t\tcase NORMAL:\n\t\t\t\t\treturn \"imgs/gui/citizen_not_give_a_fuck.png\";\n\n\t\t\t\tcase STARVING:\n\t\t\t\t\treturn \"imgs/gui/citizen_worried.png\";\n\n\t\t\t\tcase VERY_STARVING:\n\t\t\t\t\treturn \"imgs/gui/citizen_very_angry.png\";\n\t\t\t}\n\t\t};\n\t});\n\n\t// ~~~\n\n\tapp.directive(\"buildingExtInfDescription\", function(){\n\t\treturn {\n\t\t\ttemplateUrl: 'views/buildingExtendedInfo/description.html'\n\t\t};\n\t});\n\n\tapp.directive(\"buildingExtInfFull\", function(){\n\t\treturn {\n\t\t\ttemplateUrl: 'views/buildingExtendedInfo/full.html'\n\t\t};\n\t});\n\n\tapp.controller(\"BuildMenuHoverBuildingExtInfo\", function($scope){\n\t\tregisterInfiniteUpdate($scope, function(){\n\t\t\tif($scope.$$childHead === null)\n\t\t\t\treturn;\n\n\t\t\t$scope.$$childHead.bindedTo = (gameplayState.testBuilding || gameplayState.buildMenuHover);\n\t\t});\n\t});\n\n\tapp.controller(\"StaticBuildingExtInfo\", function($scope){\n\t\t$scope.$watch('building', function(){\n\t\t\tif($scope.$$childHead === null)\n\t\t\t\treturn;\n\t\t\t\n\t\t\t$scope.$$childHead.bindedTo = $scope.building;\n\t\t});\n\t});\n\n\tapp.controller(\"BuildingExtInfo\", function($scope){\n\t\t$scope.bindedTo = undefined;\n\n\t\t$scope.$watch('bindedTo', function(){\n\t\t\tif($scope.bindedTo == undefined){\n\t\t\t\t$scope.buildingName = \"\";\n\n\t\t\t\t$scope.tool = 0;\n\t\t\t\t$scope.wood = 0;\n\t\t\t\t$scope.brick = 0;\n\t\t\t\t$scope.coins = 0;\n\n\t\t\t\t$scope.side = 0;\n\n\t\t\t\t$scope.isFarm = false;\n\t\t\t\t$scope.isWorkshop = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t$scope.buildingName = $scope.bindedTo.structName;\n\n\t\t\t\t$scope.side = $scope.bindedTo.rotation;\n\n\t\t\t\t$scope.isFarm = $scope.bindedTo instanceof Farm;\n\t\t\t\t$scope.isWorkshop = $scope.bindedTo instanceof Workshop;\n\n\t\t\t\tif($scope.bindedTo instanceof ProductionBuilding){\n\t\t\t\t\t$scope.output = $scope.bindedTo.storage.catagories[OUTPUT];\n\n\t\t\t\t\t$scope.input_1 = $scope.bindedTo.storage.catagories[INPUT_1];\n\t\t\t\t\t$scope.input_2 = $scope.bindedTo.storage.catagories[INPUT_2];\n\n\t\t\t\t\t$scope.inputCrop = $scope.bindedTo.requiredCrop;\n\t\t\t\t}\n\n\t\t\t\t$scope.tool = $scope.bindedTo.requiredResources[TOOLS_ID];\n\t\t\t\t$scope.wood = $scope.bindedTo.requiredResources[WOOD_ID];\n\t\t\t\t$scope.brick = $scope.bindedTo.requiredResources[BRICKS_ID];\n\t\t\t\t$scope.coins = $scope.bindedTo.requiredResources[INVALID_ID];\n\n\t\t\t\t$scope.changeSide = function(){\n\t\t\t\t\tif($scope.bindedTo != undefined){\n\t\t\t\t\t\tvar currentIndex;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(currentIndex = 0; currentIndex < $scope.bindedTo.possibleRotation.length; currentIndex++)\n\t\t\t\t\t\t\tif($scope.bindedTo.rotation == $scope.bindedTo.possibleRotation[currentIndex])\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tvar newRotation = $scope.bindedTo.possibleRotation[\n\t\t\t\t\t\t\t(currentIndex + 1) % $scope.bindedTo.possibleRotation.length\n\t\t\t\t\t\t];\n\n\t\t\t\t\t\tif(newRotation == $scope.bindedTo.rotation){\n\t\t\t\t\t\t\tconsole.log(\"this building cannot be rotated yet\");\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$scope.bindedTo.rotation = newRotation;\n\n\t\t\t\t\t\t$scope.chooseBuilding();\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\t});\n\n\treturn new function(){\n\t\tthis.start = function(){\n\t\t\tconsole.log(\"starting AngularJS\");\n\t\t\tangular.bootstrap(document.body, [\"app\"]);\n\t\t};\n\t};\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/graphics/gui/gui.js?");

/***/ }),

/***/ "./app/scripts/graphics/layerManager.js":
/*!**********************************************!*\
  !*** ./app/scripts/graphics/layerManager.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\nlayerManager.js\n\n*/\n\nvar layerManager = new function(){\n\tvar layers = {};\n\n\tthis.setBaseLayer = function(baseImage){\n\t\tlayers[\"base\"] = baseImage;\n\t};\n\n\tthis.createLayer = function(name, callback){\n\t\tvar canvas = this.createNewLayer(name);\n\t\tvar context = canvas.getContext('2d');\n\n\t\tcallback.call(undefined, context, this.getLayer(\"base\"));\n\t}\n\n\tthis.createNewLayer = function(name){\n\t\tconsole.assert(!(name in layers));\n\n\t\tlayers[name] = document.createElement('canvas');\n\n\t\tlayers[name].width = layers[\"base\"].width;\n\t\tlayers[name].height = layers[\"base\"].height;\n\n\t\tlayers[name].getContext('2d').drawImage(layers[\"base\"], 0, 0);\n\n\t\treturn layers[name];\n\t}\n\n\tthis.getLayer = function(name){\n\t\treturn layers[name];\n\t};\n};\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){\n\treturn layerManager;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/graphics/layerManager.js?");

/***/ }),

/***/ "./app/scripts/graphics/tilePicker.js":
/*!********************************************!*\
  !*** ./app/scripts/graphics/tilePicker.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\ntilePicker.js\n\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! ../graphics/gameplayState */ \"./app/scripts/graphics/gameplayState.js\"), __webpack_require__(/*! ../graphics/drawMethod */ \"./app/scripts/graphics/drawMethod.js\"), __webpack_require__(/*! ../graphics/layerManager */ \"./app/scripts/graphics/layerManager.js\")], __WEBPACK_AMD_DEFINE_RESULT__ = (function(gameplayState, draw, layerManager){\n\treturn new function(){\n\t\t// fast, but choose only tiles, not objects\n\t\tthis.byGeometry = function(x, y){\n\t\t\tvar arr = [];\n\n\t\t\tfor(var i = 0; i < tiles.size.x; i++){\n\t\t\t\tfor(var j = 0; j < tiles.size.y; j++){\n\t\t\t\t\tvar posX = gameplayState.cameraPosition.x + i * -32 + j * 32;\n\t\t\t\t\tvar posY = gameplayState.cameraPosition.y + j * 16 + i * 16 - 16;\n\n\t\t\t\t\tif(tiles[i][j].terrainLevel >= 2)\n\t\t\t\t\t\tposY -= 20;\n\n\t\t\t\t\tif(\ty >= (posY - 16) && y <= (posY + 16) &&\n\t\t\t\t\t\tx >= (posX - 32) && x <= (posX + 32) ){\n\t\t\t\t\t\t// magic :)\n\t\t\t\t\t\tfunction calcMagicDistance(ax, ay, bx, by){\n\t\t\t\t\t\t\treturn Math.sqrt((ax - bx) * (ax - bx) / 2 + (ay - by) * (ay - by) * 2);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tarr.push([calcMagicDistance(posX, posY, x, y), tiles.coords(i, j)]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(arr.length == 0)\n\t\t\t\treturn undefined;\n\n\t\t\tarr.sort(function(a, b){\n\t\t\t\treturn a[0] - b[0];\n\t\t\t});\n\n\t\t\treturn tiles.at(arr[0][1]);\n\t\t};\n\n\t\t// ~~~\n\t\t// ~~~\n\t\t// ~~~\n\n\t\t// canvas po którym się maluje by uzyskać kolor piksela\n\t\t// większy canvas jest niepotrzebny\n\t\tvar colorPickingTestCanvas = document.createElement('canvas');\n\t\tcolorPickingTestCanvas.width = 1;\n\t\tcolorPickingTestCanvas.height = 1;\n\n\t\t// dowolna liczba większa od 0 - potrzebne by odróżniać out-of-board od tilesa (0,0)\n\t\tvar COLOR_PICKING_OFFSET = 1;\n\n\t\tfunction arrFromIntColor(intColor){\n\t\t\tvar arr = [];\n\n\t\t\tarr[0] = (intColor >> 16) & 0xFF;\n\t\t\tarr[1] = (intColor >> 8) & 0xFF;\n\t\t\tarr[2] = intColor & 0xFF;\n\n\t\t\treturn arr;\n\t\t}\n\n\t\tfunction colorIntFromArr(arr){\n\t\t\tvar intColor;\n\n\t\t\tintColor = arr[0];\n\t\t\tintColor = (intColor << 8) + arr[1];\n\t\t\tintColor = (intColor << 8) + arr[2];\n\n\t\t\treturn intColor;\n\t\t}\n\n\t\t// ~~~\n\n\t\tthis.initColorpicking = function(resources){\n\t\t\tlayerManager.createNewLayer(\"colorpicking\");\n\t\t}\n\n\t\t// slower, but very accurate\n\t\tthis.byColor = function(x, y){\n\t\t\tif(layerManager.getLayer(\"colorpicking\") == undefined)\n\t\t\t\treturn;\n\n\t\t\tvar context = colorPickingTestCanvas.getContext(\"2d\");\n\n\t\t\tvar clonedCameraPos = {\n\t\t\t\tx: gameplayState.cameraPosition.x - x + colorPickingTestCanvas.width / 2,\n\t\t\t\ty: gameplayState.cameraPosition.y - y + colorPickingTestCanvas.height / 2\n\t\t\t};\n\n\t\t\tvar colorPickingSourceCanvas_ctx = layerManager.getLayer(\"colorpicking\").getContext('2d');\n\t\t\tcolorPickingSourceCanvas_ctx.globalCompositeOperation = 'source-in';\n\t\t\t\n\t\t\t// undefined informuje metodę draw, że należy obsłużyć color picking\n\t\t\tdraw(0, context, clonedCameraPos, function(layerName, item){\n\t\t\t\tvar colorNumber = tiles.index(item.x, item.y);\n\n\t\t\t\tcolorPickingSourceCanvas_ctx.fillStyle = \"rgb(\" + arrFromIntColor(colorNumber + COLOR_PICKING_OFFSET).join(\",\") + \")\";\n\t\t\t\tcolorPickingSourceCanvas_ctx.fillRect(0, 0, colorPickingSourceCanvas_ctx.canvas.width, colorPickingSourceCanvas_ctx.canvas.height);\n\n\t\t\t\treturn colorPickingSourceCanvas_ctx.canvas;\n\t\t\t}, true);\n\n\t\t\tvar clickedTile = undefined;\n\n\t\t\tvar clickedColor = colorIntFromArr(context.getImageData(0, 0, 1, 1).data) - COLOR_PICKING_OFFSET;\n\t\t\tif(clickedColor >= 0 && tiles.exsist(clickedColor))\n\t\t\t\tclickedTile = tiles.at(clickedColor);\n\n\t\t\treturn clickedTile;\n\t\t};\n\t};\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/graphics/tilePicker.js?");

/***/ }),

/***/ "./app/scripts/logic.js":
/*!******************************!*\
  !*** ./app/scripts/logic.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n\nlogic.js\n\n*/\n\n!(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(/*! jquery */ \"./node_modules/jquery/dist/jquery.js\"),\n\t\t__webpack_require__(/*! underscore */ \"./node_modules/underscore/underscore.js\"),\n\t\t__webpack_require__(/*! extend */ \"./app/externals/extend.js\"),\n\t\t// wczytanie logiki:\n\t\t/*\n\t\t'./logic/tile',\n\t\t'./logic/algorithms',\n\t\t'./logic/product',\n\t\t'./logic/storage',\n\t\t'./logic/country',\n\t\t'./logic/island',\n\t\t'./logic/map',\n\t\t'./logic/militaryUnit',\n\t\t'./logic/ship',\n\t\t'./logic/structure',\n\t\t'./logic/building',\n\t\t'./logic/publicBuilding',\n\t\t'./logic/houseGroup',\n\t\t'./logic/storageBuilding',\n\t\t'./logic/productionBuilding',\n\t\t'./logic/civilianUnit',\n\t\t'./logic/gameDefinitions'\n\t\t*/\n\t\t], __WEBPACK_AMD_DEFINE_RESULT__ = (function(\n\t){\n\t\t\n\tHARD_UPDATE_INTERVAL = 1.0;\n\n\tfunction updateForAllNotUndefined(object, updateFuncName, param){\n\t\tfor(var i = 0; i < object.length; i++)\n\t\t\tif(object[i] != undefined)\n\t\t\t\tobject[i][updateFuncName].call(object[i], param);\n\t}\n\n\tvar hardUpdateCount = 0.0;\n\n\treturn {\n\t\ttimeFlowSpeed: 4,\n\n\t\tupdate: function(delta){\n\t\t\t// Kolejność update'ów JEST WAŻNA (islands musi być pierwsze).\n\n\t\t\thardUpdateCount += delta;\n\n\t\t\tfor(; hardUpdateCount >= HARD_UPDATE_INTERVAL; hardUpdateCount -= HARD_UPDATE_INTERVAL){\n\t\t\t\tvar gameTimeDelta = HARD_UPDATE_INTERVAL * this.timeFlowSpeed; \n\t\t\t\t\n\t\t\t\tupdateForAllNotUndefined(islands, 'hardUpdate', gameTimeDelta);\n\t\t\t\tupdateForAllNotUndefined(structures, 'hardUpdate', gameTimeDelta);\n\t\t\t\tupdateForAllNotUndefined(civilianUnits, 'hardUpdate', gameTimeDelta);\n\t\t\t\tupdateForAllNotUndefined(militaryUnits, 'hardUpdate', gameTimeDelta);\n\t\t\t}\n\n\t\t\tvar gameTimeDelta = delta * this.timeFlowSpeed;\n\n\t\t\tupdateForAllNotUndefined(islands, 'softUpdate', gameTimeDelta);\n\t\t\tupdateForAllNotUndefined(structures, 'softUpdate', gameTimeDelta);\n\t\t\tupdateForAllNotUndefined(civilianUnits, 'softUpdate', gameTimeDelta);\n\t\t\tupdateForAllNotUndefined(militaryUnits, 'softUpdate', gameTimeDelta);\n\t\t},\n\n\t\t// tymczasowe tworzenie planszy:\n\t\tinit: function(){\n\t\t\tconsole.log(\"creating map, sample buildings, etc.\");\n\n\t\t\tcreateMap(40, 50);\n\n\t\t\t// var mainIsland = new Island();\n\n\t\t\tvar playerCountry = new Country();\n\t\t\tplayerCountry.type = PLAYER_COUNTRY;\n\n\t\t\tvar ship = new Ship();\n\n\t\t\tship.setPosition(tiles.coords(19, 0));\n\t\t\t// ship.moveTo(tiles.coords(19, 1));\n\t\t\tship.countryId = playerCountry.id;\n\n\t\t\tplayerCountry.coins = 10000; // tymczasowe\n\n\t\t\ttiles[19][4].countryId = 0;\n\t\t\tvar port = new Port(19, 4, countries[0], true);\n\t\t\t\n\t\t\t\n\t\t\tislands[0].mainMarketplaces[0].storage.add(islands[0].mainMarketplaces[0].storage.special(TOOLS_ID), 100); // tymczasowe\n\t\t\tislands[0].mainMarketplaces[0].storage.add(islands[0].mainMarketplaces[0].storage.special(WOOD_ID), 100); // tymczasowe\n\t\t\tislands[0].mainMarketplaces[0].storage.add(islands[0].mainMarketplaces[0].storage.special(FOOD_ID), 5); // tymczasowe\n\t\t\t\n\n\t\t\tnew House(19, 7, countries[0]);\n\n\t\t\t/*\n\t\t\tnew Road(19, 4, countries[0]);\n\n\t\t\t// new Harbor(19, 1, countries[0]);\n\n\t\t\tnew Marketplace(21, 13, countries[0]);\n\t\t\tnew Marketplace(10, 8, countries[0]);\n\t\t\tnew Marketplace(31, 8, countries[0]);\n\n\t\t\tnew Quarry(11, 15, countries[0], undefined, WEST);\n\t\t\tnew IronMine(11, 13, countries[0], undefined, WEST);\n\t\t\t\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road((19-6) + i, 4, countries[0]);\n\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road(20 + i, 4, countries[0]);\n\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road(19, 5 + i, countries[0]);\n\n\t\t\t// new Road(20, 12, countries[0]);\n\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road((19-6) + i, 11, countries[0]);\n\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road(20 + i, 11, countries[0]);\n\n\t\t\tfor(var i = 0; i < 7; i++)\n\t\t\t\tnew Road(19, 11 + i, countries[0]);\n\n\t\t\tfor(var i = 0; i < 16; i++)\n\t\t\t\tnew Road(12, 2 + i, countries[0]);\n\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road(6 + i, 4, countries[0]);\n\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road(6 + i, 11, countries[0]);\n\n\t\t\tfor(var i = 0; i < 16; i++)\n\t\t\t\tnew Road(26, 2 + i, countries[0]);\n\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road(27 + i, 4, countries[0]);\n\n\t\t\tfor(var i = 0; i < 6; i++)\n\t\t\t\tnew Road(27 + i, 11, countries[0]);\n\t\t\t*/\n\t\t}\n\t};\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack:///./app/scripts/logic.js?");

/***/ })

}]);